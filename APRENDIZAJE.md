Se aprendieron varias cosas durante el desarrollo de la aplicación. Principalmente, considero que el conocimiento más importante adquirido se trata de las máquinas de estados finales. Al leer el problema planteado, pensé en el hecho de que SQL como tal no tiene una lista desplegable de campos, y que dichos campos no necesariamente son fijos; estos simplemente reciben un valor cualquiera acorde al tipo de campo (string, numérico, etc.). Para esto, me puse a consultar la opción de choices de Django (se usó ChatGPT y la documentación oficial de Django para indagar más sobre esto). Sin embargo, si bien la opción de choices es bastante buena para los campos fijos, no cubre por su cuenta la necesidad de transiciones lineales; se necesita todavía la validación. Se usó ChatGPT preguntando opciones para este problema y propuso la validación lógica hecha manualmente a través de Django, o usar una biblioteca. Se usó una biblioteca llamada "django-fsm", debido a que también se necesita mantener la lógica transicional en la vista de Administrador de Django, no solo en la API, y la biblioteca tenía una solución integrada para esto. Sin embargo, la biblioteca avisa que está obsoleta y sugiere migrar a otra llamada ViewFlow, pero esta no satisfizo la necesidad de validar en el panel de administrador sin adquirir la versión pro, así que se usó otra llamada "django-fsm-2", y la biblioteca conjunta para el panel de administrador, "django-fsm-2-admin". Siguiendo paso a paso la documentación, por error omití incluir la biblioteca en INSTALLED_APPS en settings.py, haciendo que Django no encontrara las plantillas que vienen con esta biblioteca. ChatGPT me advirtió que no había incluido esta biblioteca en INSTALLED_APPS, y me di cuenta así de que omití este paso accidentalmente mientras leía la documentación. Otro problema que tuve era saber que necesitaba poner el campo protected=True y poner el campo como solo lectura para la vista de administrador, pues esto no se mencionaba muy explícitamente en la introducción de la documentación; tuve que ver un ejemplo de GitHub del mismo equipo que hizo la biblioteca y luego recibir asesoría de ChatGPT para entender mejor. De esta manera quedó resuelto el tema de las transiciones en el backend.

Otro asunto aprendido es el uso de auto_now_add para los campos de fecha que se guardan al crearse; antes usaba auto_now pero me di cuenta leyendo la documentación de Django que este último actualiza la fecha cuando se guarda el modelo, y que son excluyentes.

También aprendí el método SerializerMethodField() de Django REST Framework, el cuál permite mostrar las choices con la descripción leíble para el usuario. Esto fue necesario debido a que en el frontend se recibía la choice como "EN_TRANSITO", por ejemplo, cuando debería ser "En tránsito". En el frontend, el principal desafío fue evitar que el usuario pueda ser una transición inválida. Si bien esto ya estaba en el backend, el frontend también debe tenerlo implementado, y tuve errores de lógica al principio, en los que, tras estar estancado, recurrí a la IA preguntando donde estaba el error, ya que lo estaba buscando en el manejo del select controlado con React, cuando el problema era la lógica de validación, que sobrescribía el cambio que ya había hecho anteriormente.
