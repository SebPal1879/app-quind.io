Se aprendieron varias cosas durante el desarrollo de la aplicación. Principalmente, considero que el conocimiento más importante (y difícil) adquirido se trata de las máquinas de estados finales. Al leer el problema planteado, pensé en el hecho de que SQL como tal no tiene una lista desplegable de campos, y que dichos campos no necesariamente son fijos; estos simplemente reciben un valor cualquiera acorde al tipo de campo (string, numérico, etc.). Para esto, me puse a consultar la opción de choices de Django (se usó ChatGPT y la documentación oficial de Django para indagar más sobre esto). Sin embargo, si bien la opción de choices es bastante buena para los campos fijos, no cubre por su cuenta la necesidad de transiciones lineales; se necesita todavía la validación. Se usó ChatGPT preguntando opciones para este problema y propuso la validación lógica hecha manualmente a través de Django, o usar una biblioteca. Se usó una biblioteca llamada «django-fsm», debido a que también se necesita mantener la lógica transicional en la vista de Administrador de Django, no solo en la API, y la biblioteca tenía una solución integrada para esto. Sin embargo, la biblioteca avisa que está obsoleta y sugiere migrar a otra llamada ViewFlow, pero esta no satisfizo la necesidad de validar en el panel de administrador sin adquirir la versión pro, así que se usó otra llamada «django-fsm-2», y la biblioteca conjunta para el panel de administrador, «django-fsm-2-admin». Siguiendo paso a paso la documentación, por error omití incluir la biblioteca en INSTALLED_APPS en settings.py, haciendo que Django no encontrara las plantillas que vienen con esta biblioteca. ChatGPT me advirtió que no había incluido esta biblioteca en INSTALLED_APPS, y me di cuenta así de que omití este paso accidentalmente mientras leía la documentación. Otro problema que tuve era saber que necesitaba poner el campo protected=True y poner el campo como solo lectura para la vista de administrador, pues esto no se mencionaba muy explícitamente en la introducción de la documentación; tuve que ver un ejemplo de GitHub del mismo equipo que hizo la biblioteca y luego recibir asesoría de ChatGPT para entender mejor. De esta manera quedó resuelto el tema de las transiciones en el backend.

Otro asunto aprendido es el uso de auto_now_add para los campos de fecha que se guardan al crearse; antes usaba auto_now pero me di cuenta leyendo la documentación de Django que este último actualiza la fecha cuando se guarda el modelo, y que son excluyentes.

También aprendí el método SerializerMethodField() de Django REST Framework, el cuál permite mostrar las choices con la descripción leíble para el usuario. Esto fue necesario debido a que en el frontend se recibía la choice como «EN_TRANSITO», por ejemplo, cuando debería ser «En tránsito». En el frontend, el principal desafío fue evitar que el usuario pueda ser una transición inválida. Si bien esto ya estaba en el backend, el frontend también debe tenerlo implementado, y tuve errores de lógica al principio, en los que, tras estar estancado, recurrí a la IA preguntando donde estaba el error, ya que lo estaba buscando en el manejo del select controlado con React, cuando el problema era la lógica de validación, que sobrescribía el cambio que ya había hecho anteriormente.

Sin embargo, también pregunté por correo si era estrictamente necesario permitir al usuario poder hacer clic en un estado no válido para transicionar. Tras haber recibido respuesta, y haber recibido la indicación de que no era estrictamente necesario, quise adaptar la aplicación para que solo mostrara al usuario la siguiente opción para transicionar en un botón (ej: si está creado, solo mostrar un botón para mover a en tránsito y no mostrar más opciones), y de esta manera limitar las opciones para mantener un flujo de transiciones más cerrado y claro para el usuario, manteniendo la linealidad de los estados y no dejar al usuario ser «tentado» por escoger una opción a la que no se puede transicionar. Haciendo esto, cree el botón y también quise quitar los alert() por defecto de JavaScript y usé un modal para mantener más coherencia visual (ya que los alert() pueden percibirse disruptivos con la estética de la aplicación). Haciendo el modal, me di cuenta de que no podía adaptarse el mensaje según la acción tomada, así que deduje una manera para lograrlo con useState de React manejado de manera condicional y un setter.

Otro detalle que percibí fue el hecho de que la aplicación deja introducir campos con más de 120 caracteres. Busqué en internet y al ver una respuesta en StackOverflow vi que se podía exigir la validación a través de una clase llamada MaxLengthValidator de Django. Estaba viendo como implementarla en la documentación de Django, y aprendí sobre la amplia variedad de validadores que tiene por defecto. Sin embargo, al implementar el validator, vi que seguía ocurriendo el hecho de poder agregar un campo con más caracteres. Tras desconocer el porqué y no encontrar una respuesta en internet, pregunté a ChatGPT, y me hizo saber que ocurre porque no estoy accediendo a través de los formularios de Django sino directamente a la clase, y como se está usando SQLite que viene por defecto, este simplemente deja introducir el campo porque no tiene la restricción de caracteres para Varchar.

Cosas que mejoraría con una semana más:
La lógica de estados en el backend, si bien funciona, es muy rígida, en el sentido de que las transiciones están codificadas manualmente, así que si llegara una nueva transición, tendría que establecerse manualmente. Me gustaría hacer esto de una manera dinámica, tal vez no manejándolas por nombres sino por números (con sus nombres asociados). De esta manera, se podría lograr más transiciones en caso de que el proyecto escalara, con menos esfuerzo.

Me gustaría también estilizar de una manera más profunda la parte del frontend. Si bien procuré que hubiera coherencia visual, los estilos podrían ser muchos más, ya que podría considerarse un poco simple visualmente el estado actual.

Finalmente, optimizaría en el backend (settings.py) para que eventualmente la página pudiera desplegarse. Esto se puede hacer juntando las configuraciones comunes de desarrollo y producción en un solo archivo, y separando las configuraciones que no coinciden en archivos aparte. También se podría hacer configuraciones similares con el frontend, ya que ambos actualmente están configurados para desarrollo y no para despliegue.

Para agregar historial de ubicaciones por paquete, haría lo siguiente:
Crearía una nueva clase de Models.py llamada HistorialUbicaciones. Esta clase tendría dos campos: una clave foránea que referencia el ID del Paquete, un campo ciudad (llevando un poco más de complejidad, se podría hacer otra clase Ciudades y referenciar con una clave foránea el ID de estas), y por último un campo de fecha y hora. Cada que el paquete se mueve, simplemente tiene que registrar el ID del paquete, el ID de ciudad, y se guarda la fecha y hora automáticamente con el argumento de Django «auto_now_add»
